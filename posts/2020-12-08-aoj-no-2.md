---
title: My Notes on AOJ 2
editedDate: 2020/12/12
tags: competitive-programming
---

<i>This article was translated from [my Japanese blog](https://igarash1-sol.hatenablog.com/).</i>

---

#### [2442 ConvexCut](http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2442)


Assuming that there exists a point P which the area is bisected for any lines on, 
a line parallel to the x-axis and y-axes passing through the point 
can also bisect the area. 
We also know that for every vertex there is another vertex that is point-symmetric to it. Conversely, if such a point P exists, then any line passing through it will bisect its area. After all, we only need to check if each vertex pair is point-symmetric with respect to the same point. 
Since the constraints are not tight, it's possible to solve the problem by just iterating over points in O(N^4).


#### [2382 King Slime](http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2382)

---


If you go backward from the point where it becomes the King Slime, 
it is easy to see that the slime can only stay at the initial point of each slime or at the wall. 
If other slimes exit on the x-axis or y-axis, it is better to connect the slimes to them.
If the slimes are connected in this way,
there will be at most one slime in each x-coordinate and y-coordinate, 
and the slimes will be arranged like a diagonal line. 
Finally, it's best to connect the slimes by moving them to the wall. 
Since there are 4 walls, we need to find the minimum number of moves in each wall. 
In some cases, you aren't necessary to drive the slime to the corner (it was a little bothersome). 
Since the order of these cases also matters, it is better to treat them as connected components of a undirected graph.
You can use Union Find in this time. The runtime complexity is O(N * Ack(N) + W + H).


---

#### [1350 There is No Alternative](http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1350)

Build MST with the graph without each edge, and if you can't build MST or the sum of the MST edges is greater than the original MST (the case you don't exclude any edges), 
then you can determine that the edge is No Alternative Bridge. 
However, the runtime complexity of this solution is O(number of edges) * O(runtime complexity of the MST) 
and we cannot make it in time. 
As you notice any two MSTs have many common edges, we have only O(N) edges to examine. 
In the end, we can solve for O(N * E log N).


#### [2303 Marathon Match](http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2303)

---

Let's define some variables as follows:

- P[i][j] := the probability that player i will rest j times,
- G[i][t] := the probability that player i will reach the goal at time t,
- W[i][t] := the probability that player i will win at time t,
- $T_{ij}$ := L/V[i] + j * T[i] (the time it takes for athlete i to finish, taking a rest j times)

And then,

- G[i][t] = Σ_{j} P[i][j] (t = Tij),
- W[i][t] = G[i][t] * (1 - Σ_{k ! = i, t' <= t}G[k][t'])

and the probability that athlete i will win will be ΣW[i][t]. 
The time to finish may not be an integer, 
but the time depends only on the speed of the player and 
the number of rest periods (and rest periods) of the player, 
G and W can be calculated simultaneously and solved in O(N^2M^2). 
At first, I used `std::cout` but I got WA by the output format error.
Although I ended up using `printf` to specify the number of digits, maybe we could use `std:cout` (I didn't come up...)

---

#### [2741 Invisible](http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2741)

Passing the turn removes all the cards from the stack, 
so the stack is never placed with cards from the same player in a row and placed from Player 1 and Player 2 in turn.. 
Thus, with the number of cards remaining in each player's deck and the information of the last player who placed a card on the stack, 
the cards in the stack can be reconstructed, 
including their order. 
Since the number of states is O(n * m * (n + m) * 4), you can solve it by memoization or dynamic programming. 

---

#### [2304 Reverse Roads](https://onlinejudge.u-aizu.ac.jp/problems/2304)


Since we never use two opposite edges in the maximum flow (since they cancel each other out, there is no such increase path in both directions at the same time).
, find the maximum flow in the original graph with the opposite edges (or, alternatively, we can think of it as an undirected graph), 
and check if the opposite edges are used in the maximum flow obtained.

---

#### [2425 A Holiday of Miss Brute Force](https://onlinejudge.u-aizu.ac.jp/problems/2425)

Since the instructions of the sister depend only on the remainder 
of the coordinates and elapsed time divided by 6, 
the number of states can be reduced to O(lx * ly * 6). 
We will find the shortest path on the graph with the states as nodes and the number of times the sister will be ignored as the cost. 
Note that the instructions also depends on the parity of x-coordinates. 
The total runtime complexity is O(N log N) (where N = lx * ly).


---

#### [2297 Rectangular Stamps](https://onlinejudge.u-aizu.ac.jp/problems/2297)
 
Notice that the part of the picture that was last stamped can be stamped with any previous stamps,
the number of possibilities is only O(2^16) if we consider any part of the picture. 
The minimum number of stamps required to complete a state of cells is determined by the minimum number of stamps required to complete the state 
before each stamped square of the state as a corner, 
we can get a recurrence and compute it by DP. 
For each state, we need to press each square with one of the four corners of each stamp, 
so the runtime complexity is O(2^16 * N * 4 * 4). 
After I used memoization and got TLE, I switched to DP and got AC.


----

#### [1236 Map of Ninja House](https://onlinejudge.u-aizu.ac.jp/problems/1236)

The probelm is in short, "Given a preorder traversal in a graph, so reconstruct the graph."
Easy problem. You can solve it by both O(V + E) DFS and O(V^2) DFS. 
In some cases, there are several possible rooms that have already been passed through such that the distance from the first room is the same, 
so be careful to connect the room with the one that has more vacancy in the number of doors.

----

#### [2342 A Light Road](https://onlinejudge.u-aizu.ac.jp/problems/2342)

Considering the number of mirrors P and Q in each square and the direction from which the square was reached, we can see that the square does not return to its own state (in the graph, the state is DAG). 
Therefore, it is sufficient to ignore the path and perform DP considering only that states, 
and the runtime complexity is O(A^2 * 4 * NM).


----


#### [2595 Cookie Counter](https://onlinejudge.u-aizu.ac.jp/problems/2595)

Let's define:

- f(d, c) = In d days, the total number of ways to eat more than 1 cookie a day and eat c cookies in total (including the order), 

We can then compute $f(i,N) * D_{C_i}$ for each i ($i \leq min(D, N)$).


----

#### [2342 Curtain](https://onlinejudge.u-aizu.ac.jp/problems/2747)

Since the window edge is either parallel to the x-axis or parallel to the y-axis, 
and the curtain is given counterclockwise, 
the left sides of the window (the side that goes from the negative x-axis edge to the inside of the polygon) 
and the right sides of the window (the side that goes from the positive x-axis edge to the inside of the polygon) 
can be determined by the y-corrdinates(up or down).
By moving the left and right sides in and out of the polygon and 
sweeping the plane along the x-axis, 
the area of the window that is not covered by the curtain can be calculated. 
Cutting all the perpendicular edges by the y-coordinates of given vertices beforehand makes the implementation easier as the rectangles that emerge during sweeping the plane are either all covered by the curtain or do not overlap entirely. 
The runtime complexity is now O(N^2).
[SPOJ WINDOW1](https://www.spoj.com/problems/WINDOW1/) is a similar looking problem, 
and it can actually be solved with the same sweep line method in amortized O(N^2)).
The official solution is to compress the coordinate system and look at each square with O(N^3),
which is far easier to implement and very clever.

---

#### [2643 AI](https://onlinejudge.u-aizu.ac.jp/problems/2643)

Parsing. Be careful about infinite loops and recursions.

---

#### [2784 Similarity of Subtrees](https://onlinejudge.u-aizu.ac.jp/problems/2784)

TODO.

#### [2720 Identity Function](https://onlinejudge.u-aizu.ac.jp/problems/2720)

---

TODO.

#### [2726 Black Company](https://onlinejudge.u-aizu.ac.jp/problems/2726)

---

TODO.

#### [2726 Floating-Point Numbers](https://onlinejudge.u-aizu.ac.jp/problems/1628)

---

